sulotion                                                                                                                PAGE 1
                         1     ;simon.asm - Game of Simon Says for 8051 Microcontroller
                         2     ;Copyright (C) 2006 Danko Krajisnik
                         3
                         4     ;This program is free software; you can redistribute it and/or
                         5     ;modify it under the terms of the GNU General Public License
                         6     ;as published by the Free Software Foundation; either version 2
                         7     ;of the License, or (at your option) any later version.
                         8
                         9     ;This program is distributed in the hope that it will be useful,
                        10     ;but WITHOUT ANY WARRANTY; without even the implied warranty of
                        11     ;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        12     ;GNU General Public License for more details.
                        13
                        14     ;You should have received a copy of the GNU General Public License
                        15     ;along with this program; if not, write to the Free Software
                        16     ;Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
                        17
                        18     #include "8051equ.inc"
****ERROR: Unknown keyword: `#include'
	`#include' is neither macro nor instruction nor directive
                        19
                        20     ; start switch
  00B7                  21     start_sw    .equ    P3.7
                        22
                        23     ; input switches
  00B2                  24     red_sw        .equ    P3.2
  00B3                  25     green_sw    .equ    P3.3
  00B4                  26     yellow_sw    .equ    P3.4
  00B5                  27     blue_sw    .equ    P3.5
                        28
                        29     ; output LED's
  0094                  30     red_led    .equ    P1.4
  0095                  31     green_led    .equ    P1.5
  0096                  32     yellow_led    .equ    P1.6
  0097                  33     blue_led    .equ    P1.7
                        34
                        35
                        36     ; status LED's
  00B0                  37     wrong_led    .equ    P3.0
  00B1                  38     right_led    .equ    P3.1
                        39
  0030                  40     counter    .equ    30h
  0031                  41     input_val    .equ    31h
  0040                  42     sequence        .equ    40h
                        43
                        44     .org    00h
                        45         ajmp    start
                        46
                        47     .org    03h
                        48         reti
                        49
                        50     .org    0bh
                        51         reti
                        52
                        53     .org    13h
                        54         reti
                        55
                        56     .org    1bh
                        57         reti
                        58
                        59     .org    23h
                        60         reti
                        61
                        62     .org    25h
                        63         reti
                        64
                        65     ; delay for short time
                        66     delay_short:
                        67         mov    r7, #0ffh
                        68         djnz    r7, $
                        69         ret
                        70
                        71     ; delay longer
                        72     delay_medium:
                        73         mov    r6, #0ffh
                        74     loop_delay_medium:
                        75         acall    delay_short
                        76         djnz    r6, loop_delay_medium
                        77         ret
                        78
                        79     ; delay even longer
                        80     delay_long:
                        81         mov    r5, #04h
                        82     loop_delay_long:
                        83         acall    delay_medium
                        84         djnz    r5, loop_delay_long
                        85         ret
                        86
                        87     ; flash red status led 3 times
                        88     ; to be used after incorrect input sequence
                        89     flash_wrong:
                        90         clr    wrong_led
                        91         acall    delay_medium
                        92         setb    wrong_led
                        93         acall    delay_medium
                        94         clr    wrong_led
                        95         acall    delay_medium
                        96         setb    wrong_led
                        97         acall    delay_medium
                        98         clr    wrong_led
                        99         acall    delay_medium
                       100         setb    wrong_led
                       101         ret
                       102
                       103     ; flash green status led once
                       104     ; to be used after every correct user input sequence
                       105     flash_right:
                       106         clr    right_led
                       107         acall    delay_medium
                       108         setb    right_led
                       109         ret
                       110
                       111     ; flash green status led 3 times
                       112     ; to be used after counter is maxed out
                       113     flash_win:
                       114         clr    right_led
                       115         acall    delay_medium
                       116         setb    right_led
                       117         acall    delay_medium
                       118         clr    right_led
                       119         acall    delay_medium
                       120         setb    right_led
                       121         acall    delay_medium
                       122         clr    right_led
                       123         acall    delay_medium
                       124         setb    right_led
                       125         ret
                       126
                       127     ; flash the red led
                       128     flash_red:
                       129         clr    red_led
                       130         acall    delay_medium
                       131         setb    red_led
                       132         ret
                       133
                       134     ; flash the green led
                       135     flash_green:
                       136         clr    green_led
                       137         acall    delay_medium
                       138         setb    green_led
                       139         ret
                       140
                       141     ; flash the yellow led
                       142     flash_yellow:
                       143         clr    yellow_led
                       144         acall    delay_medium
                       145         setb    yellow_led
                       146         ret
                       147
                       148     ; flash the blue led
                       149     flash_blue:
                       150         clr    blue_led
                       151         acall    delay_medium
                       152         setb    blue_led
                       153         ret
                       154
                       155     ; add extra random byte to sequence sequence
                       156     add_random:
                       157         mov    a, #sequence
                       158         add    a, counter
                       159         mov    r0, a
                       160         mov    a, TL0
                       161
                       162         ; divide timer value by 2 - fix odd/even issues
                       163         mov    B, #02h
                       164         div    ab
                       165
                       166         ; isolate lowest 2 bits (random byte will be 0 - 3)
                       167         mov    B, #040h
                       168         mul    ab
                       169         mov    B, #040h
                       170         div    ab
                       171
                       172         mov    @r0, a
                       173         inc    counter
                       174         ret
                       175
                       176     ; read input switch
                       177     ; store value in input_val
                       178     ; input_val is modified as follows:
                       179     ; 0 - red switch was pressed
                       180     ; 1 - green switch was pressed
                       181     ; 2 - yellow switch was pressed
                       182     ; 3 - blue switch was pressed
                       183     read_switch:
                       184         jnb    blue_sw, blue_sw_input
                       185         jnb    yellow_sw, yellow_sw_input
                       186         jnb    green_sw, green_sw_input
                       187         jnb    red_sw, red_sw_input
                       188         ajmp    read_switch
                       189     red_sw_input:
                       190         acall    flash_red
                       191         mov    input_val, #00h
                       192         jnb    red_sw, $
                       193         ret
                       194     green_sw_input:
                       195         acall    flash_green
                       196         mov    input_val, #01h
                       197         jnb    green_sw, $
                       198         ret
                       199     yellow_sw_input:
                       200         acall    flash_yellow
                       201         mov    input_val, #02h
                       202         jnb    yellow_sw, $
                       203         ret
                       204     blue_sw_input:
                       205         acall    flash_blue
                       206         mov    input_val, #03h
                       207         jnb    blue_sw, $
                       208         ret
                       209
                       210     ; flash entire sequence of sequence
                       211     flash_sequence:
                       212         mov    r0, #00h
                       213     flash_sequence_loop:
                       214         mov    a, counter
                       215         subb    a, r0
                       216         jz    flash_sequence_loop_end
                       217
                       218         mov    a, #sequence
                       219         add    a, r0
                       220         mov    r1, a
                       221         mov    a, @r1
                       222
                       223         ; if sequence is 0 - flash red led
                       224         jz    flash_sequence_red
                       225
                       226         ; if sequence is 1 - flash green led
                       227         subb    a, #01h
                       228         jz    flash_sequence_green
                       229
                       230         ; if sequence is 2 - flash yellow led
                       231         subb    a, #01h
                       232         jz    flash_sequence_yellow
                       233
                       234         ; else (sequence is 3) - flash blue led
                       235         ajmp    flash_sequence_blue
                       236
                       237     flash_sequence_red:
                       238         acall    flash_red
                       239         ajmp    flash_sequence_over
                       240     flash_sequence_green:
                       241         acall    flash_green
                       242         ajmp    flash_sequence_over
                       243     flash_sequence_yellow:
                       244         acall    flash_yellow
                       245         ajmp    flash_sequence_over
                       246     flash_sequence_blue:
                       247         acall    flash_blue
                       248
                       249     flash_sequence_over:
                       250         acall    delay_long
                       251
                       252         inc    r0
                       253         ajmp    flash_sequence_loop
                       254     flash_sequence_loop_end:
                       255         ret
                       256
                       257     ; read switch and compare user input to stored sequence
                       258     accept_input:
                       259         mov    r0, #00h
                       260         mov    r4, #00h
                       261     accept_input_loop:
                       262         mov    a, counter
                       263         subb    a, r0
                       264         jz    accept_input_loop_end
                       265
                       266         acall    read_switch
                       267
                       268         mov    a, #sequence
                       269         add    a, r0
                       270         mov    r1, a
                       271         mov    a, @r1
                       272
                       273         subb    a, input_val
                       274         jz    accept_input_loop_cont
                       275         mov    r4, #01h
                       276         ajmp    accept_input_loop_end
                       277
                       278     accept_input_loop_cont:
                       279
                       280         inc    r0
                       281         ajmp    accept_input_loop
                       282
                       283     accept_input_loop_end:
                       284         ret
                       285
                       286     init:
                       287         ; timer 0 - 16 bit mode
                       288         mov    TMOD, #01h
                       289         setb    TR0
                       290
                       291         mov    PSW, #00h
                       292         mov    IE, #00h
                       293
                       294         ; initialize counter
                       295         mov    counter, #00h
                       296
                       297         ; activate switches
                       298         setb    red_sw
                       299         setb    green_sw
                       300         setb    yellow_sw
                       301         setb    blue_sw
                       302         setb    start_sw
                       303
                       304         ret
                       305
                       306     start:
                       307         acall    init
                       308
                       309     ; wait for user to press and release start switch
                       310     wait_start_sw:
                       311         jb    start_sw, $
                       312         jnb    start_sw, $
                       313
                       314         acall    delay_long
                       315         acall    delay_long
                       316
                       317     loop:
                       318         acall    add_random
                       319         acall    flash_sequence
                       320         acall    accept_input
                       321
                       322         acall    delay_long
                       323
                       324         mov    a, r4
                       325         jz    cont1
                       326
                       327         acall    flash_wrong
                       328         mov    counter, #00h
                       329         ajmp    wait_start_sw
                       330
                       331     cont1:
                       332         mov    a, counter
                       333         cjne    a, #0Ah, cont2
                       334
                       335         acall    flash_win
                       336         mov    counter, #00h
                       337         ajmp    wait_start_sw
                       338
                       339     cont2:
                       340         acall    flash_right
                       341         acall    delay_long
                       342         ajmp    loop
                       343
                       344     .end
ASSEMBLY COMPLETE, 1 ERROR FOUND, NO WARNINGS


ERROR SUMMARY:
Line 18, ERROR: Unknown keyword: `#include'
	`#include' is neither macro nor instruction nor directive

SYMBOL TABLE:
??MCU_8051_IDE . . . . . . . . . . .  N  NUMB  8051H  NOT USED
??VERSION. . . . . . . . . . . . . .  N  NUMB  0146H  NOT USED
AC . . . . . . . . . . . . . . . . .  B  ADDR  00D6H  NOT USED
ACC. . . . . . . . . . . . . . . . .  D  ADDR  00E0H  NOT USED
ACCEPT_INPUT . . . . . . . . . . . .  C  ADDR  00FFH
ACCEPT_INPUT_LOOP. . . . . . . . . .  C  ADDR  0103H
ACCEPT_INPUT_LOOP_CONT . . . . . . .  C  ADDR  0117H
ACCEPT_INPUT_LOOP_END. . . . . . . .  C  ADDR  011AH
ACSR . . . . . . . . . . . . . . . .  D  ADDR  0097H  NOT USED
ADCF . . . . . . . . . . . . . . . .  D  ADDR  00F6H  NOT USED
ADCLK. . . . . . . . . . . . . . . .  D  ADDR  00F2H  NOT USED
ADCON. . . . . . . . . . . . . . . .  D  ADDR  00F3H  NOT USED
ADDH . . . . . . . . . . . . . . . .  D  ADDR  00F5H  NOT USED
ADDL . . . . . . . . . . . . . . . .  D  ADDR  00F4H  NOT USED
ADD_RANDOM . . . . . . . . . . . . .  C  ADDR  008AH
AUXR . . . . . . . . . . . . . . . .  D  ADDR  008EH  NOT USED
AUXR1. . . . . . . . . . . . . . . .  D  ADDR  00A2H  NOT USED
B. . . . . . . . . . . . . . . . . .  D  ADDR  00F0H
BDRCON . . . . . . . . . . . . . . .  D  ADDR  009BH  NOT USED
BDRCON_1 . . . . . . . . . . . . . .  D  ADDR  009CH  NOT USED
BLUE_LED . . . . . . . . . . . . . .  N  NUMB  0097H
BLUE_SW. . . . . . . . . . . . . . .  N  NUMB  00B5H
BLUE_SW_INPUT. . . . . . . . . . . .  C  ADDR  00CAH
BRL. . . . . . . . . . . . . . . . .  D  ADDR  009AH  NOT USED
CCAP0H . . . . . . . . . . . . . . .  D  ADDR  00FAH  NOT USED
CCAP0L . . . . . . . . . . . . . . .  D  ADDR  00EAH  NOT USED
CCAP1H . . . . . . . . . . . . . . .  D  ADDR  00FBH  NOT USED
CCAP1L . . . . . . . . . . . . . . .  D  ADDR  00EBH  NOT USED
CCAP2H . . . . . . . . . . . . . . .  D  ADDR  00FCH  NOT USED
CCAP3H . . . . . . . . . . . . . . .  D  ADDR  00FDH  NOT USED
CCAP4H . . . . . . . . . . . . . . .  D  ADDR  00FEH  NOT USED
CCAPL2H. . . . . . . . . . . . . . .  D  ADDR  00FCH  NOT USED
CCAPL2L. . . . . . . . . . . . . . .  D  ADDR  00ECH  NOT USED
CCAPL3H. . . . . . . . . . . . . . .  D  ADDR  00FDH  NOT USED
CCAPL3L. . . . . . . . . . . . . . .  D  ADDR  00EDH  NOT USED
CCAPL4H. . . . . . . . . . . . . . .  D  ADDR  00FEH  NOT USED
CCAPL4L. . . . . . . . . . . . . . .  D  ADDR  00EEH  NOT USED
CCAPM0 . . . . . . . . . . . . . . .  D  ADDR  00DAH  NOT USED
CCAPM1 . . . . . . . . . . . . . . .  D  ADDR  00DBH  NOT USED
CCAPM2 . . . . . . . . . . . . . . .  D  ADDR  00DCH  NOT USED
CCAPM3 . . . . . . . . . . . . . . .  D  ADDR  00DDH  NOT USED
CCAPM4 . . . . . . . . . . . . . . .  D  ADDR  00DEH  NOT USED
CCF0 . . . . . . . . . . . . . . . .  B  ADDR  00D8H  NOT USED
CCF1 . . . . . . . . . . . . . . . .  B  ADDR  00D9H  NOT USED
CCF2 . . . . . . . . . . . . . . . .  B  ADDR  00DAH  NOT USED
CCF3 . . . . . . . . . . . . . . . .  B  ADDR  00DBH  NOT USED
CCF4 . . . . . . . . . . . . . . . .  B  ADDR  00DCH  NOT USED
CCON . . . . . . . . . . . . . . . .  D  ADDR  00D8H  NOT USED
CFINT. . . . . . . . . . . . . . . .  C  ADDR  0033H  NOT USED
CH . . . . . . . . . . . . . . . . .  D  ADDR  00F9H  NOT USED
CKCON. . . . . . . . . . . . . . . .  D  ADDR  008FH  NOT USED
CKCON0 . . . . . . . . . . . . . . .  D  ADDR  008FH  NOT USED
CKRL . . . . . . . . . . . . . . . .  D  ADDR  0097H  NOT USED
CKSEL. . . . . . . . . . . . . . . .  D  ADDR  0085H  NOT USED
CL . . . . . . . . . . . . . . . . .  D  ADDR  00E9H  NOT USED
CLKREG . . . . . . . . . . . . . . .  D  ADDR  008FH  NOT USED
CMOD . . . . . . . . . . . . . . . .  D  ADDR  00D9H  NOT USED
CONT1. . . . . . . . . . . . . . . .  C  ADDR  0152H
CONT2. . . . . . . . . . . . . . . .  C  ADDR  015EH
COUNTER. . . . . . . . . . . . . . .  N  NUMB  0030H
CPRL2. . . . . . . . . . . . . . . .  B  ADDR  00C8H  NOT USED
CR . . . . . . . . . . . . . . . . .  B  ADDR  00DEH  NOT USED
CT2. . . . . . . . . . . . . . . . .  B  ADDR  00C9H  NOT USED
CY . . . . . . . . . . . . . . . . .  B  ADDR  00D7H  NOT USED
DELAY_LONG . . . . . . . . . . . . .  C  ADDR  0032H
DELAY_MEDIUM . . . . . . . . . . . .  C  ADDR  002BH
DELAY_SHORT. . . . . . . . . . . . .  C  ADDR  0026H
DP0H . . . . . . . . . . . . . . . .  D  ADDR  0083H  NOT USED
DP0L . . . . . . . . . . . . . . . .  D  ADDR  0082H  NOT USED
DP1H . . . . . . . . . . . . . . . .  D  ADDR  0085H  NOT USED
DP1L . . . . . . . . . . . . . . . .  D  ADDR  0084H  NOT USED
DPH. . . . . . . . . . . . . . . . .  D  ADDR  0083H  NOT USED
DPL. . . . . . . . . . . . . . . . .  D  ADDR  0082H  NOT USED
EA . . . . . . . . . . . . . . . . .  B  ADDR  00AFH  NOT USED
EC . . . . . . . . . . . . . . . . .  B  ADDR  00AEH  NOT USED
EECON. . . . . . . . . . . . . . . .  D  ADDR  0096H  NOT USED
ES . . . . . . . . . . . . . . . . .  B  ADDR  00ACH  NOT USED
ET0. . . . . . . . . . . . . . . . .  B  ADDR  00A9H  NOT USED
ET1. . . . . . . . . . . . . . . . .  B  ADDR  00ABH  NOT USED
ET2. . . . . . . . . . . . . . . . .  B  ADDR  00ADH  NOT USED
EX0. . . . . . . . . . . . . . . . .  B  ADDR  00A8H  NOT USED
EX1. . . . . . . . . . . . . . . . .  B  ADDR  00AAH  NOT USED
EXEN2. . . . . . . . . . . . . . . .  B  ADDR  00CBH  NOT USED
EXF2 . . . . . . . . . . . . . . . .  B  ADDR  00CEH  NOT USED
EXTI0. . . . . . . . . . . . . . . .  C  ADDR  0003H  NOT USED
EXTI1. . . . . . . . . . . . . . . .  C  ADDR  0013H  NOT USED
F0 . . . . . . . . . . . . . . . . .  B  ADDR  00D5H  NOT USED
FE . . . . . . . . . . . . . . . . .  B  ADDR  009FH  NOT USED
FLASH_BLUE . . . . . . . . . . . . .  C  ADDR  0083H
FLASH_GREEN. . . . . . . . . . . . .  C  ADDR  0075H
FLASH_RED. . . . . . . . . . . . . .  C  ADDR  006EH
FLASH_RIGHT. . . . . . . . . . . . .  C  ADDR  0050H
FLASH_SEQUENCE . . . . . . . . . . .  C  ADDR  00D3H
FLASH_SEQUENCE_BLUE. . . . . . . . .  C  ADDR  00F7H
FLASH_SEQUENCE_GREEN . . . . . . . .  C  ADDR  00EFH
FLASH_SEQUENCE_LOOP. . . . . . . . .  C  ADDR  00D5H
FLASH_SEQUENCE_LOOP_END. . . . . . .  C  ADDR  00FEH
FLASH_SEQUENCE_OVER. . . . . . . . .  C  ADDR  00F9H
FLASH_SEQUENCE_RED . . . . . . . . .  C  ADDR  00EBH
FLASH_SEQUENCE_YELLOW. . . . . . . .  C  ADDR  00F3H
FLASH_WIN. . . . . . . . . . . . . .  C  ADDR  0057H
FLASH_WRONG. . . . . . . . . . . . .  C  ADDR  0039H
FLASH_YELLOW . . . . . . . . . . . .  C  ADDR  007CH
GREEN_LED. . . . . . . . . . . . . .  N  NUMB  0095H
GREEN_SW . . . . . . . . . . . . . .  N  NUMB  00B3H
GREEN_SW_INPUT . . . . . . . . . . .  C  ADDR  00B8H
IE . . . . . . . . . . . . . . . . .  D  ADDR  00A8H
IE0. . . . . . . . . . . . . . . . .  B  ADDR  0089H  NOT USED
IE1. . . . . . . . . . . . . . . . .  B  ADDR  008BH  NOT USED
INIT . . . . . . . . . . . . . . . .  C  ADDR  011BH
INPUT_VAL. . . . . . . . . . . . . .  N  NUMB  0031H
INT0 . . . . . . . . . . . . . . . .  B  ADDR  00B2H  NOT USED
INT1 . . . . . . . . . . . . . . . .  B  ADDR  00B3H  NOT USED
IP . . . . . . . . . . . . . . . . .  D  ADDR  00B8H  NOT USED
IPH. . . . . . . . . . . . . . . . .  D  ADDR  00B7H  NOT USED
IPH0 . . . . . . . . . . . . . . . .  D  ADDR  00B7H  NOT USED
IPH1 . . . . . . . . . . . . . . . .  D  ADDR  00B3H  NOT USED
IPL0 . . . . . . . . . . . . . . . .  D  ADDR  00B8H  NOT USED
IPL1 . . . . . . . . . . . . . . . .  D  ADDR  00B2H  NOT USED
IT0. . . . . . . . . . . . . . . . .  B  ADDR  0088H  NOT USED
IT1. . . . . . . . . . . . . . . . .  B  ADDR  008AH  NOT USED
KBE. . . . . . . . . . . . . . . . .  D  ADDR  009DH  NOT USED
KBF. . . . . . . . . . . . . . . . .  D  ADDR  009EH  NOT USED
KBLS . . . . . . . . . . . . . . . .  D  ADDR  009CH  NOT USED
LOOP . . . . . . . . . . . . . . . .  C  ADDR  0140H
LOOP_DELAY_LONG. . . . . . . . . . .  C  ADDR  0034H
LOOP_DELAY_MEDIUM. . . . . . . . . .  C  ADDR  002DH
OSCCON . . . . . . . . . . . . . . .  D  ADDR  0086H  NOT USED
OV . . . . . . . . . . . . . . . . .  B  ADDR  00D2H  NOT USED
P. . . . . . . . . . . . . . . . . .  B  ADDR  00D0H  NOT USED
P0 . . . . . . . . . . . . . . . . .  D  ADDR  0080H  NOT USED
P1 . . . . . . . . . . . . . . . . .  D  ADDR  0090H  NOT USED
P1M1 . . . . . . . . . . . . . . . .  D  ADDR  00D4H  NOT USED
P1M2 . . . . . . . . . . . . . . . .  D  ADDR  00E2H  NOT USED
P2 . . . . . . . . . . . . . . . . .  D  ADDR  00A0H  NOT USED
P3 . . . . . . . . . . . . . . . . .  D  ADDR  00B0H  NOT USED
P3M1 . . . . . . . . . . . . . . . .  D  ADDR  00D5H  NOT USED
P3M2 . . . . . . . . . . . . . . . .  D  ADDR  00E3H  NOT USED
P4 . . . . . . . . . . . . . . . . .  D  ADDR  00C0H  NOT USED
P4M1 . . . . . . . . . . . . . . . .  D  ADDR  00D6H  NOT USED
P4M2 . . . . . . . . . . . . . . . .  D  ADDR  00E4H  NOT USED
P5 . . . . . . . . . . . . . . . . .  D  ADDR  00E8H  NOT USED
PC . . . . . . . . . . . . . . . . .  B  ADDR  00BEH  NOT USED
PCON . . . . . . . . . . . . . . . .  D  ADDR  0087H  NOT USED
PPCL . . . . . . . . . . . . . . . .  B  ADDR  00BEH  NOT USED
PS . . . . . . . . . . . . . . . . .  B  ADDR  00BCH  NOT USED
PSL. . . . . . . . . . . . . . . . .  B  ADDR  00BCH  NOT USED
PSW. . . . . . . . . . . . . . . . .  D  ADDR  00D0H
PT0. . . . . . . . . . . . . . . . .  B  ADDR  00B9H  NOT USED
PT0L . . . . . . . . . . . . . . . .  B  ADDR  00B9H  NOT USED
PT1. . . . . . . . . . . . . . . . .  B  ADDR  00BBH  NOT USED
PT1L . . . . . . . . . . . . . . . .  B  ADDR  00BBH  NOT USED
PT2. . . . . . . . . . . . . . . . .  B  ADDR  00BDH  NOT USED
PT2L . . . . . . . . . . . . . . . .  B  ADDR  00BDH  NOT USED
PX0. . . . . . . . . . . . . . . . .  B  ADDR  00B8H  NOT USED
PX0L . . . . . . . . . . . . . . . .  B  ADDR  00B8H  NOT USED
PX1. . . . . . . . . . . . . . . . .  B  ADDR  00BAH  NOT USED
PX1L . . . . . . . . . . . . . . . .  B  ADDR  00BAH  NOT USED
RB8. . . . . . . . . . . . . . . . .  B  ADDR  009AH  NOT USED
RCAP2H . . . . . . . . . . . . . . .  D  ADDR  00CBH  NOT USED
RCAP2L . . . . . . . . . . . . . . .  D  ADDR  00CAH  NOT USED
RCLK . . . . . . . . . . . . . . . .  B  ADDR  00CDH  NOT USED
RD . . . . . . . . . . . . . . . . .  B  ADDR  00B7H  NOT USED
READ_SWITCH. . . . . . . . . . . . .  C  ADDR  00A1H
RED_LED. . . . . . . . . . . . . . .  N  NUMB  0094H
RED_SW . . . . . . . . . . . . . . .  N  NUMB  00B2H
RED_SW_INPUT . . . . . . . . . . . .  C  ADDR  00AFH
REN. . . . . . . . . . . . . . . . .  B  ADDR  009CH  NOT USED
RESET. . . . . . . . . . . . . . . .  C  ADDR  0000H  NOT USED
RI . . . . . . . . . . . . . . . . .  B  ADDR  0098H  NOT USED
RIGHT_LED. . . . . . . . . . . . . .  N  NUMB  00B1H
RS0. . . . . . . . . . . . . . . . .  B  ADDR  00D3H  NOT USED
RS1. . . . . . . . . . . . . . . . .  B  ADDR  00D4H  NOT USED
RXD. . . . . . . . . . . . . . . . .  B  ADDR  00B0H  NOT USED
SADDR. . . . . . . . . . . . . . . .  D  ADDR  00A9H  NOT USED
SADDR_0. . . . . . . . . . . . . . .  D  ADDR  00A9H  NOT USED
SADDR_1. . . . . . . . . . . . . . .  D  ADDR  00AAH  NOT USED
SADEN. . . . . . . . . . . . . . . .  D  ADDR  00B9H  NOT USED
SADEN_0. . . . . . . . . . . . . . .  D  ADDR  00B9H  NOT USED
SADEN_1. . . . . . . . . . . . . . .  D  ADDR  00BAH  NOT USED
SBUF . . . . . . . . . . . . . . . .  D  ADDR  0099H  NOT USED
SCON . . . . . . . . . . . . . . . .  D  ADDR  0098H  NOT USED
SEQUENCE . . . . . . . . . . . . . .  N  NUMB  0040H
SINT . . . . . . . . . . . . . . . .  C  ADDR  0023H  NOT USED
SM0. . . . . . . . . . . . . . . . .  B  ADDR  009FH  NOT USED
SM1. . . . . . . . . . . . . . . . .  B  ADDR  009EH  NOT USED
SM2. . . . . . . . . . . . . . . . .  B  ADDR  009DH  NOT USED
SP . . . . . . . . . . . . . . . . .  D  ADDR  0081H  NOT USED
SPCON. . . . . . . . . . . . . . . .  D  ADDR  00C3H  NOT USED
SPCR . . . . . . . . . . . . . . . .  D  ADDR  00D5H  NOT USED
SPDAT. . . . . . . . . . . . . . . .  D  ADDR  00C5H  NOT USED
SPDR . . . . . . . . . . . . . . . .  D  ADDR  0086H  NOT USED
SPSR . . . . . . . . . . . . . . . .  D  ADDR  00AAH  NOT USED
SPSTA. . . . . . . . . . . . . . . .  D  ADDR  00C4H  NOT USED
START. . . . . . . . . . . . . . . .  C  ADDR  0134H
START_SW . . . . . . . . . . . . . .  N  NUMB  00B7H
T0 . . . . . . . . . . . . . . . . .  B  ADDR  00B4H  NOT USED
T1 . . . . . . . . . . . . . . . . .  B  ADDR  00B5H  NOT USED
T2CON. . . . . . . . . . . . . . . .  D  ADDR  00C8H  NOT USED
T2MOD. . . . . . . . . . . . . . . .  D  ADDR  00C9H  NOT USED
TB8. . . . . . . . . . . . . . . . .  B  ADDR  009BH  NOT USED
TCLK . . . . . . . . . . . . . . . .  B  ADDR  00CCH  NOT USED
TCON . . . . . . . . . . . . . . . .  D  ADDR  0088H  NOT USED
TF0. . . . . . . . . . . . . . . . .  B  ADDR  008DH  NOT USED
TF1. . . . . . . . . . . . . . . . .  B  ADDR  008FH  NOT USED
TF2. . . . . . . . . . . . . . . . .  B  ADDR  00CFH  NOT USED
TH0. . . . . . . . . . . . . . . . .  D  ADDR  008CH  NOT USED
TH1. . . . . . . . . . . . . . . . .  D  ADDR  008DH  NOT USED
TH2. . . . . . . . . . . . . . . . .  D  ADDR  00CDH  NOT USED
TI . . . . . . . . . . . . . . . . .  B  ADDR  0099H  NOT USED
TIMER0 . . . . . . . . . . . . . . .  C  ADDR  000BH  NOT USED
TIMER1 . . . . . . . . . . . . . . .  C  ADDR  001BH  NOT USED
TIMER2 . . . . . . . . . . . . . . .  C  ADDR  002BH  NOT USED
TL0. . . . . . . . . . . . . . . . .  D  ADDR  008AH
TL1. . . . . . . . . . . . . . . . .  D  ADDR  008BH  NOT USED
TL2. . . . . . . . . . . . . . . . .  D  ADDR  00CCH  NOT USED
TMOD . . . . . . . . . . . . . . . .  D  ADDR  0089H
TR0. . . . . . . . . . . . . . . . .  B  ADDR  008CH
TR1. . . . . . . . . . . . . . . . .  B  ADDR  008EH  NOT USED
TR2. . . . . . . . . . . . . . . . .  B  ADDR  00CAH  NOT USED
TXD. . . . . . . . . . . . . . . . .  B  ADDR  00B1H  NOT USED
WAIT_START_SW. . . . . . . . . . . .  C  ADDR  0136H
WDTCON . . . . . . . . . . . . . . .  D  ADDR  00A7H  NOT USED
WDTPRG . . . . . . . . . . . . . . .  D  ADDR  00A7H  NOT USED
WDTRST . . . . . . . . . . . . . . .  D  ADDR  00A6H  NOT USED
WR . . . . . . . . . . . . . . . . .  B  ADDR  00B6H  NOT USED
WRONG_LED. . . . . . . . . . . . . .  N  NUMB  00B0H
YELLOW_LED . . . . . . . . . . . . .  N  NUMB  0096H
YELLOW_SW. . . . . . . . . . . . . .  N  NUMB  00B4H
YELLOW_SW_INPUT. . . . . . . . . . .  C  ADDR  00C1H